# 消息通知模块使用指南

## 概述

消息通知模块采用**事件驱动架构**，实现了站内消息和邮件通知两种渠道，支持用户偏好设置、批量发送、重试机制等功能。

## 核心特性

### ✅ 已实现功能

1. **事件驱动架构** - 业务代码与通知逻辑解耦
2. **多渠道支持** - 站内消息 + 邮件通知
3. **用户偏好设置** - 支持按类型和渠道控制通知
4. **批量处理** - 支持批量发送，性能优化
5. **异步处理** - 不阻塞主业务流程
6. **重试机制** - 邮件发送失败自动重试（最多3次）
7. **优先级支持** - 支持低、普通、高、紧急四个优先级

## 架构设计

### 事件驱动流程

```
业务代码
  ↓
发布 NotificationEvent
  ↓
NotificationEventListener 监听事件
  ↓
NotificationService 处理通知
  ↓
根据用户偏好选择渠道
  ↓
NotificationChannelStrategy 发送通知
  ├─ InAppNotificationChannel (站内消息)
  └─ EmailNotificationChannel (邮件)
```

### 核心组件

1. **NotificationEvent** - 通知事件
2. **NotificationEventListener** - 事件监听器
3. **NotificationService** - 通知服务
4. **NotificationChannelStrategy** - 通知渠道策略接口
5. **NotificationEventPublisher** - 事件发布工具类

## 使用方法

### 1. 在业务代码中发布通知事件

#### 方式一：使用 NotificationEventPublisher（推荐）

```java
@Service
@RequiredArgsConstructor
public class ClubServiceImpl {
    private final NotificationEventPublisher notificationEventPublisher;

    public void reviewApplication(ReviewApplicationRequest request) {
        // ... 业务逻辑 ...
        
        // 审核完成后发布通知事件
        if (status == ApplicationStatus.APPROVED) {
            Club club = this.getById(application.getClubId());
            String title = "加入社团申请已通过";
            String content = String.format("恭喜！你加入【%s】的申请已通过审核。", club.getName());
            
            notificationEventPublisher.publishNotification(
                application.getUserId(),
                title,
                content,
                NotificationType.AUDIT,
                "club",
                application.getClubId(),
                NotificationPriority.NORMAL
            );
        } else {
            String title = "加入社团申请未通过";
            String content = String.format("很抱歉，你加入【%s】的申请未通过审核。", club.getName());
            
            notificationEventPublisher.publishNotification(
                application.getUserId(),
                title,
                content,
                NotificationType.AUDIT,
                "club",
                application.getClubId(),
                NotificationPriority.NORMAL
            );
        }
    }
}
```

#### 方式二：直接使用 ApplicationEventPublisher

```java
@Service
@RequiredArgsConstructor
public class ActivityServiceImpl {
    private final ApplicationEventPublisher eventPublisher;

    public void signupActivity(Long activityId) {
        // ... 业务逻辑 ...
        
        // 报名成功后发布通知
        NotificationEvent event = new NotificationEvent(
            this,
            userId,
            "活动报名成功",
            "你已成功报名【" + activity.getTitle() + "】活动",
            NotificationType.ACTIVITY,
            "activity",
            activityId,
            NotificationPriority.NORMAL
        );
        eventPublisher.publishEvent(event);
    }
}
```

### 2. 常见通知场景示例

#### 用户注册成功

```java
notificationEventPublisher.publishNotification(
    user.getId(),
    "欢迎加入平台",
    "欢迎你注册学校社团管理平台！快去浏览感兴趣的社团和活动吧。",
    NotificationType.SYSTEM,
    null,
    null,
    NotificationPriority.NORMAL
);
```

#### 活动审核结果

```java
if (status == ActivityStatus.PUBLISHED) {
    notificationEventPublisher.publishNotification(
        activity.getCreateUser(),
        "活动审核通过",
        "你创建的活动【" + activity.getTitle() + "】已通过审核并发布。",
        NotificationType.AUDIT,
        "activity",
        activityId,
        NotificationPriority.HIGH
    );
}
```

#### 活动即将开始（批量通知）

```java
// 获取所有已报名用户
List<Long> userIds = activitySignupMapper.selectList(
    new LambdaQueryWrapper<ActivitySignup>()
        .eq(ActivitySignup::getActivityId, activityId)
        .eq(ActivitySignup::getStatus, SignupStatus.SIGNED_UP)
).stream()
.map(ActivitySignup::getUserId)
.collect(Collectors.toList());

// 批量发送通知
notificationEventPublisher.publishNotification(
    userIds,
    "活动即将开始",
    "你报名的活动【" + activity.getTitle() + "】将于1小时后开始，请准时参加。",
    NotificationType.ACTIVITY,
    "activity",
    activityId,
    NotificationPriority.URGENT
);
```

## API 接口

### 用户端通知接口

| 接口 | 方法 | 说明 | 权限 |
|------|------|------|------|
| `/api/notification/list` | GET | 分页查询我的通知 | user |
| `/api/notification/unread-count` | GET | 获取未读数量 | user |
| `/api/notification/mark-read` | PUT | 标记已读 | user |
| `/api/notification/{id}` | DELETE | 删除通知 | user |
| `/api/notification/settings` | GET | 获取通知设置 | user |
| `/api/notification/settings` | PUT | 更新通知设置 | user |

### 请求示例

#### 查询通知列表

```bash
GET /api/notification/list?pageNum=1&pageSize=10&type=audit&readFlag=false
```

#### 标记已读

```bash
PUT /api/notification/mark-read
Content-Type: application/json

{
  "notificationId": 1,
  "markAll": false
}
```

#### 更新通知设置

```bash
PUT /api/notification/settings
Content-Type: application/json

{
  "emailEnabled": true,
  "inAppEnabled": true,
  "auditNotification": true,
  "activityNotification": true,
  "clubNotification": false,
  "systemNotification": true
}
```

## 配置说明

### 邮件配置（application.yaml）

```yaml
spring:
  mail:
    host: smtp.qq.com  # 邮件服务器地址
    port: 587
    username: ${MAIL_USERNAME:your-email@qq.com}
    password: ${MAIL_PASSWORD:your-auth-code}  # 授权码，不是登录密码
    default-encoding: UTF-8
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
    from: ${MAIL_FROM:noreply@campus-club.com}  # 发件人地址
```

### 环境变量配置

```bash
# Windows
set MAIL_USERNAME=your-email@qq.com
set MAIL_PASSWORD=your-auth-code
set MAIL_FROM=noreply@campus-club.com

# Linux/Mac
export MAIL_USERNAME=your-email@qq.com
export MAIL_PASSWORD=your-auth-code
export MAIL_FROM=noreply@campus-club.com
```

## 数据库表结构

### notification 表

已存在，新增了 `priority` 字段用于优先级。

### user_notification_setting 表

用户通知偏好设置表，在用户首次访问通知设置时自动创建默认配置。

## 扩展新渠道

如果需要添加新的通知渠道（如短信、微信等），只需：

1. 实现 `NotificationChannelStrategy` 接口
2. 使用 `@Component` 注解注册为 Spring Bean
3. 系统会自动识别并支持该渠道

示例：

```java
@Component
@RequiredArgsConstructor
public class SmsNotificationChannel implements NotificationChannelStrategy {
    
    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.SMS;
    }
    
    @Override
    public boolean send(Long userId, String title, String content, NotificationType type) {
        // 实现短信发送逻辑
        return true;
    }
    
    // ... 其他方法实现
}
```

## 性能优化

1. **批量插入** - 站内消息使用批量插入，减少数据库操作
2. **异步处理** - 所有通知发送都是异步的，不阻塞主流程
3. **线程池配置** - 使用独立的线程池处理通知任务
4. **重试机制** - 邮件发送失败自动重试，避免临时故障导致通知丢失

## 注意事项

1. **邮件发送频率** - 避免短时间内大量发送邮件，可能被判定为垃圾邮件
2. **用户偏好** - 发送通知前会检查用户偏好设置，已禁用的不会发送
3. **异常处理** - 通知发送失败不会影响主业务流程，只记录日志
4. **幂等性** - 当前版本未实现幂等性，重复发布事件会发送重复通知（可在业务层控制）

## 后续优化建议

1. **消息队列** - 如果并发量大，可引入 RabbitMQ/RocketMQ
2. **通知聚合** - 同类通知合并发送，减少通知轰炸
3. **WebSocket** - 实时推送未读通知数量
4. **通知模板** - 使用模板引擎统一管理通知内容
5. **监控告警** - 监控通知发送成功率，异常时告警


